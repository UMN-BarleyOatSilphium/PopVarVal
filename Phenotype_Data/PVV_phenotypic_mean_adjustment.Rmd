---
title: "PopVarVal Mean Phenotypic Adjustment"
output: html_notebook
---

## Introduction

This notebook will outline some modeling procedures for calculating BLUEs for the
experimental entries in the PVV trials

First some setup, including package loading and directory setting


```{r setup}

library(tidyverse)
library(lme4)
library(modelr)
library(readxl)
library(stringr)
library(broom)
library(pbr)
library(purrrlyr)

# Project directory
proj_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/PopVarVal/"

proj_pheno_dir <- file.path(proj_dir, "Phenotypic_Data")
result_dir <- file.path(proj_dir, "/Results/")

# Phenotypic data directory
pheno_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/Genomic Selection/Phenotypic Data/Final/2017/"




# Entry information
pvv_train <- read_excel(path = file.path(proj_dir, "Plant_Material/PopVarVal_project_entries.xlsx"))

# Training pop
tp <- pvv_train %>% 
  filter(Purpose == "S2TP") %>%
  pull(Line)

# Checks
train_checks <- pvv_train %>% 
  filter(Purpose == "Check_set1") %>% 
  pull(Line)

pvv_entry <- read_excel(path = file.path(proj_dir, "Plant_Material/PopVarVal_project_entries.xlsx"),
                        sheet = "Entries")

# Separate by check, parent, and entry
checks <- pvv_entry %>% 
  filter(Purpose == "Check_set2") %>% 
  pull(Line)

parents <- pvv_entry %>% 
  filter(Purpose == "Parent") %>% 
  pull(Line)

entries <- pvv_entry %>% 
  filter(Purpose == "Experimental") %>% 
  pull(Line)

```




## Adjustment


### Training Data

Read in the data for the training population


Adjust training data for each experimental design using either the model

$$
y_{ikl} = \mu + G_i + b_k + \epsilon_{ikl}
$$
or

$$
y_{il} = \mu + G_i + \epsilon_{il}
$$



```{r adj.tr}

load(file.path(proj_pheno_dir, "PVV_train_tidy.RData" ))

# Convert necessary variables to factors
# Add new variables to separate entries from checks
# We will use only checks as checks (not parents)
p_train_tidy <- PopVarVal_tidy %>% 
  mutate(line_name = as.character(line_name)) %>%
  mutate(entry = if_else(line_name %in% train_checks, "00check", line_name),
         check = if_else(line_name %in% train_checks, line_name, "00entry")) %>%
  mutate_at(vars(-value), as.factor) %>%
  # Filter out heading date data from FHB trials
  filter(!(str_detect(trial, "FHB") & trait == "HeadingDate"))



## Calculate BLUEs for all traits
train_BLUEs <- p_train_tidy %>%
  group_by(trait, environment) %>%
  filter(sum(line_name %in% tp) > 1) %>%
  droplevels() %>%
  group_by(trait, environment) %>%
  nest() %>%
  by_row(function(i) {
    # Grab data
    df <- unnest(i)
    
    # print(unlist(distinct(df, trait, environment)))
    
    # Create formula - remove intercept
    # Fit block effect if present
    if (!is.na(df$blk[1])) {
      form <- value ~ -1 + entry + check + (1|blk)
      fit <- lmer(formula = form, data = df)
      
      # Tidy
      fit_tidy <- tidy(fit)
      
    } else {
      form <- value ~ -1 + entry + check
      fit <- lm(formula = form, data = df)
      
      # Tidy
      fit_tidy <- tidy(fit) %>%
        mutate(group = "fixed")
    }
    
    # Filter for entries
    entry_coef <- fit_tidy %>% 
      filter(str_detect(term, "entry"), group == "fixed", !str_detect(term, "check")) %>%
      mutate(term = str_replace(term, "entry", "")) %>%
      select(line_name = term, value = estimate, std.error)
    
    # Return a df with the model fit and the blues
    data_frame(fit = list(fit), entry_coef = list(entry_coef)) }, .to = "out")

## Unnest
PVV_train_BLUEs <- train_BLUEs %>% 
  unnest(out) %>% 
  unnest(entry_coef)

# For each line, calculate the genotype BLUE
PVV_train_BLUEs_summ <- PVV_train_BLUEs %>%
  filter(trait != "PlumpGrain") %>%
  group_by(trait) %>%
  do({
    
    # Grab data
    df <- rename(., env = environment)
    # Weights
    wts <- df$std.error^2
    
    # Use sommer to calculate BLUEs
    mf <- model.frame(value ~ line_name + env + std.error, df)
    # Response
    y <- model.response(mf)
    
    # How many environments?
    if (n_distinct(df$env) <= 1) {
      X <- model.matrix(~ -1 + line_name, mf)
      Z <- diag(length(y))
      
    } else {
      X <- model.matrix(~ -1 + line_name + env, mf)
      Z <- model.matrix(~ line_name:env, mf)
      
    } 
    
    # K
    K <- diag(ncol(Z))
    # fit
    fit <- sommer::mmer(Y = y, X = X, Z = list(int = list(Z = Z, K = K)),
                        R = list(res = diag(wts)))
    
    # Extract BLUEs and return
    fit$beta.hat %>% 
      data.frame(line_name = row.names(.), value = ., 
                 row.names = NULL, stringsAsFactors = FALSE) %>% 
      filter(str_detect(line_name, "line_name")) %>% 
      mutate(line_name = str_replace(line_name, "line_name", "")) %>%
      rename(value = T1) })
      

save_file <- file.path(proj_pheno_dir, "PVV_train_BLUEs.RData")
save("PVV_train_BLUEs", "PVV_train_BLUEs_summ", file = save_file)

```


### Data from Progeny

Read in the data

```{r}

load(file.path(pheno_dir, "2017_PVV_tidy_data.RData"))

# Convert necessary variables to factors
# Add new variables to separate entries from checks
# We will use only checks as checks (not parents)
p_tidy <- fbt_tidy_2017_pvv %>% 
  mutate(entry = if_else(line_name %in% checks, "00check", line_name),
         check = if_else(line_name %in% checks, line_name, "00entry")) %>%
  mutate_at(vars(-value), as.factor)





```



Calculate BLUEs for all traits

There are some traits, like HeadingDate and PlantHeight that were evaluated in multiple
trials in the same environment (plus there are lines that were in one trial, but not
both). For those traits with multiple trials in the same environment, we will use 
the following model:

$$
y_{ijkl} = \mu + G_i + t_j + b_{k(j)} + \epsilon_{ijkl} 
$$


For traits measured in a single trial, we will use the following model:

$$
y_{ikl} = \mu + G_i + b_k + \epsilon_{ikl}
$$

where $y_{ikl}$ is the phenotype, $\mu$ is the grand mean, $G_i$ is the random effect of the *i*th genotype, $\beta_k$ is the random effect of the *k*th block and $\epsilon_{ikl}$ is the error associated with that phenotypic observation. $G_i$ is modeled as $G_i = g_i + c_i$, where $g_i$ is the effect of the *i*th entry with $i = 1, ..., n_g$, and $c_i$ is the effect of the *i*th check, with $i = n_g + 1, ..., n_c$.

For FHBSeverity, a continuous term for the HeadingDate will be added:

$$
y_{ikl} = \mu + G_i + b_k + h_i + \epsilon_{ikl}
$$

where $h_i$ is the heading date of the *i*th genotype

Calculate BLUEs

```{r solve.blues}

## Calculate BLUEs for HD and PH
model_out1 <- p_tidy %>% 
  filter(trait != "FHBSeverity") %>%
  group_by(trait, environment) %>%
  do({
    # Grab data
    df <- .
    
    # Create formula - remove intercept
    if (n_distinct(df$trial) > 1) {
      form <- value ~ -1 + entry + check + trial + (1|blk:trial)
    } else {
      form <- value ~ -1 + entry + check + (1|blk)
    }
    
    # Model
    fit <- lmer(formula = form, data = df)
    # Tidy
    fit_tidy <- tidy(fit)
    
    # Filter for entries
    entry_coef <- fit_tidy %>% 
      filter(str_detect(term, "entry"), group == "fixed", !str_detect(term, "check")) %>%
      mutate(term = str_replace(term, "entry", "")) %>%
      select(line_name = term, value = estimate, std.error)
    
    # Return a df with the model fit and the blues
    data_frame(fit = list(fit), entry_coef = list(entry_coef)) })

## Fit models for FHB with different covariables (i.e. traits)
fhb_model_check <- p_tidy %>% 
  filter(trait != "FHBSeverity") %>% 
  spread(trait, value) %>% 
  right_join(., filter(p_tidy, trait == "FHBSeverity")) %>%
  group_by(trait, environment) %>%
  do({
    # Grab data
    df <- .
    
    # Create formula - remove intercept
    base <- value ~ -1 + (1|entry) + check + (1|blk)
    base_hd <- value ~ -1 + (1|entry) + check + (1|blk) + (1 | HeadingDate)
    
    forms <- list(
      base = base,
      base_hd = base_hd
    )
    
    # Model
    fits <- fit_with(data = df, lmer, forms)
    
    # LRT for heading date and height
    data_frame(form = names(forms), fits = fits) %>% 
      mutate(logLik = map_dbl(fits, logLik), LR = 2 * c(NA, diff(logLik)), 
             df = 1, p_value = pchisq(q = LR, df = df, lower.tail = FALSE) / 2) })

## Calculate BLUEs for FHB. Use HeadingDate as a covariable
model_out2 <- p_tidy %>% 
  filter(trait != "FHBSeverity") %>% 
  spread(trait, value) %>% 
  right_join(., filter(p_tidy, trait == "FHBSeverity")) %>%
  group_by(trait, environment) %>%
  do({
    # Grab data
    df <- .
    
    # Create formula - remove intercept
    form <- value ~ -1 + entry + check + (1|blk) + (1 | HeadingDate)
    
    # Model
    fit <- lmer(formula = form, data = df)
    # Tidy
    fit_tidy <- tidy(fit)
    
    # Filter for entries
    entry_coef <- fit_tidy %>% 
      filter(str_detect(term, "entry"), group == "fixed", !str_detect(term, "check")) %>%
      mutate(term = str_replace(term, "entry", "")) %>%
      select(line_name = term, value = estimate, std.error)
    
    # Return a df with the model fit and the blues
    data_frame(fit = list(fit), entry_coef = list(entry_coef)) })

# Combine blues
model_blues <- bind_rows(model_out1, model_out2)
    
# Save this
save_file <- file.path(proj_pheno_dir, "PopVarVal_BLUE_model.RData")
save("model_blues", "fhb_model_check", file = save_file)  


```



Use the individual environment BLUEs to calculate across-environment BLUEs and 
to model GxE and heritability


$$
y_{ij} = \mu + g_i + t_j + (gt)_{ij} + \epsilon_{ij}
$$

where $y_{ij}$ is the phenotype, $\mu$ is the grand mean, $g_i$ is the random effect of the *i*th genotype, $t_j$ is the fixed effect of the *j*th environment, $(gt)_{ij}$ is the random effect of the interaction between the *i*th genotype and the *j*th environment, and $\epsilon_{ij}$ is the error associated with that phenotypic observation.

Assess the significance of GxE and calculate heritability - need to remove the parents

```{r gxe.sig}

# Load BLUEs
load(file.path(proj_pheno_dir, "PopVarVal_BLUE_model.RData"))


# Subset the parents
PVV_BLUEs_parents <- model_blues %>% 
  unnest(entry_coef) %>%
  filter(str_detect(line_name, "^2MS14"))

PVV_BLUEs_progeny <- model_blues %>% 
  unnest(entry_coef) %>%
  filter(!str_detect(line_name, "^2MS14"))

## Assess the significance of GxE
PVV_progeny_model_check <- PVV_BLUEs_progeny %>%
  group_by(trait) %>%
  do({
    # Grab the data
    df <- select(., trait, env = environment, names(.))
    # Weights
    wts <- df$std.error^2
    
    # Models
    forms <- formulas(~ value,
                      base = ~ (1|line_name) + env,
                      base_ge = add_predictors(base, ~ (1|line_name:env)))
    
    lmer_control <- lmerControl(check.nobs.vs.nlev = "ignore", check.nobs.vs.nRE = "ignore")
    
    fits <- fit_with(data = df, .f = lmer, .formulas = forms, control = lmer_control,
                     weights = wts)
    
    ## LRT
    data_frame(form = names(forms), fits = fits) %>% 
      mutate(logLik = map_dbl(fits, logLik), LR = 2 * c(NA, diff(logLik)), 
             df = 1, p_value = pchisq(q = LR, df = df, lower.tail = FALSE) / 2) })

PVV_progeny_model_check


```

Compute heritability

```{r herit}

# Heritabilities
PVV_progeny_herit <- PVV_BLUEs_progeny %>%
  group_by(trait) %>%
  nest() %>%
  by_row(function(i) {
    # Grab the data
    df <- unnest(i) %>%
      select(trait, env = environment, names(.))
    # Weights
    wts <- df$std.error^2
    
    # Harmonic mean of environments and reps
    plot_table <- xtabs(~ line_name + env, data = df)
    
    # Find the number of environments
    n_e <- plot_table %>%
      ifelse(. > 1, 1, .) %>%
      rowSums() %>% 
      harm_mean()
    
    # Now replicates
    n_r <- plot_table %>% 
      harm_mean()
    
    # Models
    form <- value ~ (1|line_name) + env + (1|line_name:env)
    
    lmer_control <- lmerControl(check.nobs.vs.nlev = "ignore", check.nobs.vs.nRE = "ignore")
    
    # Model
    fit <- lmer(formula = form, data = df, control = lmer_control, weights = wts)
    # Heritability - bootstrap the CI
    herit_boot(object = fit, exp = "line_name / (line_name + (line_name:env / n_e) + (Residual / (n_e * n_r)))",
               n_r = n_r, n_e = n_e, boot.reps = 250) 
    
    }, .to = "out")


## Plot
(g_herit <- PVV_progeny_herit %>% 
  ggplot(aes(x = trait, y = heritability - bias)) + 
  geom_col() + 
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.5) +
  ylim(c(-0.1,1)))


```


Estimate the genetic variance per family per trait

```{r model}

# Use the BLUEs in each environment to calculate the estimated genetic variance
# for each family. Also return the BLUPs for progeny within families
# First add family information to the progeny
PVV_family_varG <- PVV_BLUEs_progeny %>%
  mutate(family = str_extract(line_name, "4[0-9]{3}")) %>%
  # Group by family and calculate the genetic variance and the heritability
  group_by(trait, family) %>%
  do({
    # Grab the data
    df <- rename(., env = environment)
    
    # Harmonic mean of number of environments
    plot_table <- xtabs(~ line_name + env, data = df)
    n_e <- plot_table %>%
      ifelse(. > 1, 1, .) %>%
      rowSums() %>% 
      harm_mean()
    
    # Function to extract genetic variance from fitted model
    get_varG <- function(x) subset(as.data.frame(VarCorr(x)), grp == "line_name", vcov, drop = T)
    
    ## Condition on number of environments
    if (n_distinct(df$env) <= 1) {
      # Models
      fixed_form <- value ~ 1
      mixed_form <- value ~ (1|line_name)
      
    } else {
      # Models and fit
      mixed_form <- value ~ env + (1|line_name)
      fixed_form <- value ~ env
      
    }
    
    fits <- list(
      base = lm(formula = fixed_form, data = df),
      base_g = lmer(formula = mixed_form, data = df, control = lmer_control)
    )
    
    # Extract the V_G estimate 
    varG_hat <- get_varG(fits$base_g)
  
    ## LRT of genetic variance
    LR <- as.numeric(-2 * (logLik(fits$base) - logLik(fits$base_g)))
    p_value <- pchisq(q = LR, df = 1, lower.tail = FALSE) / 2
    
    h <- herit(object = fits$base_g, exp = "line_name / (line_name + (Residual / n_e))",
               n_e = n_e)
     
    # Bootstrap a CI for the estimate of genetic variance
    suppressWarnings(varG_boots <- bootMer(x = fits$base_g, FUN = get_varG, nsim = 1000))
     
    bias <- mean(varG_boots$t) - varG_boots$t0
    se <- sd(varG_boots$t)
    ci_upper <- quantile(varG_boots$t, 0.975)
    ci_lower <- quantile(varG_boots$t, 0.025)
    
    # Fit the model with line_name as fixed effect
    if (n_distinct(df$env) <= 1) {
      new_fixed <- value ~ -1 + line_name
    } else {
      new_fixed <- as.formula(paste("value ~ -1 + line_name +", as.character(fixed_form)[3]))
    }
    
      fit2 <- lm(formula = new_fixed, data = df)
    
    # Extract BLUEs
    prog_BLUE <- tidy(fit2) %>% 
      filter(str_detect(term, "line_name")) %>% 
      select(line_name = term, value = estimate) %>% 
      mutate(line_name = str_replace(line_name, "line_name", ""))
      
    # Return a data.frame
    data_frame(varG_hat = varG_hat, se = se, bias = bias, ci_lower = ci_lower, 
               ci_upper = ci_upper, h = h, LR = LR, p_value = p_value,
               prog_BLUE = list(prog_BLUE)) })





## Estimate genetic correlations between traits
## Define functions

 
# Function to extract genetic correlation from fitted model
get_rhoG <- function(x) {
  as.data.frame(VarCorr(x)) %>% 
    filter(grp == "line_name", !is.na(var2)) %>% 
    select(trait1 = var1, trait2 = var2, rhoG = sdcor) %>% 
    mutate(trait1 = if_else(trait1 == "(Intercept)", levels(x@frame$trait)[1], trait1),
           trait1 = str_replace(trait1, "trait", ""),
           trait2 = str_replace(trait2, "trait", "")) }

# Define functions to get the pairs of correlations
get_rhoG_t1t2 <- function(x) {
  as.data.frame(VarCorr(x)) %>% 
    filter(grp == "line_name", !is.na(var2)) %>% 
    select(trait1 = var1, trait2 = var2, rhoG = sdcor) %>% 
    mutate(trait1 = if_else(trait1 == "(Intercept)", levels(x@frame$trait)[1], trait1),
           trait1 = str_replace(trait1, "trait", ""),
           trait2 = str_replace(trait2, "trait", "")) %>%
    subset(trait1 == levels(x@frame$trait)[1] & trait2 == levels(x@frame$trait)[2], rhoG, drop = T) }

get_rhoG_t1t3 <- function(x) {
  as.data.frame(VarCorr(x)) %>% 
    filter(grp == "line_name", !is.na(var2)) %>% 
    select(trait1 = var1, trait2 = var2, rhoG = sdcor) %>% 
    mutate(trait1 = if_else(trait1 == "(Intercept)", levels(x@frame$trait)[1], trait1),
           trait1 = str_replace(trait1, "trait", ""),
           trait2 = str_replace(trait2, "trait", "")) %>%
    subset(trait1 == levels(x@frame$trait)[1] & trait2 == levels(x@frame$trait)[3], rhoG, drop = T) }

get_rhoG_t2t3 <- function(x) {
  as.data.frame(VarCorr(x)) %>% 
    filter(grp == "line_name", !is.na(var2)) %>% 
    select(trait1 = var1, trait2 = var2, rhoG = sdcor) %>% 
    mutate(trait1 = if_else(trait1 == "(Intercept)", levels(x@frame$trait)[1], trait1),
           trait1 = str_replace(trait1, "trait", ""),
           trait2 = str_replace(trait2, "trait", "")) %>%
    subset(trait1 == levels(x@frame$trait)[2] & trait2 == levels(x@frame$trait)[3], rhoG, drop = T) }




PVV_family_rhoG <- PVV_BLUEs_progeny %>%
  mutate(family = str_extract(line_name, "4[0-9]{3}")) %>%
  # Group by family and calculate the genetic variance and the heritability
  group_by(family) %>%
  do({
    # Grab the data
    df <- rename(., env = environment)
    
    # Scale
    df1 <- df %>%
      group_by(trait) %>%
      mutate(value = scale(value))
    
    ## Condition on number of environments
    if (n_distinct(df$env) <= 1) {
      # Models
      mixed_form <- value ~ (trait|line_name)
      
    } else {
      # Models and fit
      mixed_form <- value ~ env + (trait|line_name)
      
    }
    
    fit_corr_g = lmer(formula = mixed_form, data = df1)
    
    # Extract the V_G estimate 
    rhoG_hat <- get_rhoG(fit_corr_g)
     
    # Bootstrap a CI for the estimate of genetic correlation
    suppressWarnings(rhoG_boots <- list(get_rhoG_t1t2, get_rhoG_t1t3, get_rhoG_t2t3) %>%
      map(~bootMer(x = fit_corr_g, FUN = ., nsim = 50)))
    
    bias <- rhoG_boots %>%
      map_dbl(~ mean(.$t) - .$t0)
    se <- rhoG_boots %>%
      map_dbl(~ sd(.$t))
    ci_lower <- rhoG_boots %>%
      map_dbl(~quantile(.$t, 0.025))
    ci_upper <- rhoG_boots %>%
      map_dbl(~quantile(.$t, 0.975))
    
    # Combine this data
    # Return a data.frame
    rhoG_hat %>% 
      mutate(bias = bias, se = se, ci_lower = ci_lower, ci_upper = ci_upper) })


# Save the estimates of genetic variance
save_file <- file.path(result_dir, "PVV_varG_estimates.RData")
save("PVV_family_varG", file = save_file)




```


Use the same models from above to calculate BLUEs

```{r blues}

# Model HeadingDate
hd_fit_blue <- p_tidy %>%
  filter(trait == "HeadingDate") %>%
  lmer(value ~ -1 + line_name + (1|line_name:environment) + (1|environment/blk), data = .)

# Grab the line name of the intercept
first_line <- model.frame(hd_fit_blue) %>% 
  arrange(line_name) %>% 
  distinct(line_name) %>% 
  pull(line_name) %>% 
  head(1) %>%
  as.character()

# Recenter on the intercept, if present
if (fixef(hd_fit_blue) %>% head(1) %>% names() %>% str_detect("Intercept")) {
  hd_blue <- hd_fit_blue %>%
    fixef() %>%
    tidy() %>% 
    mutate(x = c(x[1], scale(x[-1], center = -1 * x[1], scale = FALSE)),
           names = c(first_line, str_replace(names[-1], "line_name", "")),
           trait = "HeadingDate")
  
} else {
  hd_blue <- hd_fit_blue %>%
    fixef() %>%
    tidy() %>% 
    mutate(names = str_replace(names, "line_name", ""),
           trait = "HeadingDate")
    
}

# Model PlantHeight - needs adjustment after more data
ph_fit_blue <- p_tidy1 %>%
  filter(trait == "PlantHeight") %>%
  lmer(value ~ -1 + line_name + (1|environment:blk), data = .)

# Grab the line name of the intercept
first_line <- model.frame(ph_fit_blue) %>% 
  arrange(line_name) %>% 
  distinct(line_name) %>% 
  pull(line_name) %>% 
  head(1) %>%
  as.character()

# Recenter on the intercept, if present
if (fixef(ph_fit_blue) %>% head(1) %>% names() %>% str_detect("Intercept")) {
  ph_blue <- ph_fit_blue %>%
    fixef() %>%
    tidy() %>% 
    mutate(x = c(x[1], scale(x[-1], center = -1 * x[1], scale = FALSE)),
           names = c(first_line, str_replace(names[-1], "line_name", "")),
           trait = "PlantHeight")
  
} else {
  ph_blue <- ph_fit_blue %>%
    fixef() %>%
    tidy() %>% 
    mutate(names = str_replace(names, "line_name", ""),
           trait = "PlantHeight")
    
}

# Model FHB Severity
fhb_fit_blue <- p_tidy1 %>% 
  filter(trait %in% c("FHBSeverity", "HeadingDate")) %>% 
  select(-value_scale) %>% 
  spread(trait, value) %>% 
  gather(trait, value, -1:-10, -HeadingDate) %>%
  lmer(value ~ -1 + line_name + (1:environment) + (1|line_name:environment) + (1|environment:blk) + (1|HeadingDate), data = .)

# Grab the line name of the intercept
first_line <- model.frame(fhb_fit_blue) %>% 
  arrange(line_name) %>% 
  distinct(line_name) %>% 
  pull(line_name) %>% 
  head(1) %>%
  as.character()

# Recenter on the intercept, if present
if (fixef(fhb_fit_blue) %>% head(1) %>% names() %>% str_detect("Intercept")) {
  fhb_blue <- fhb_fit_blue %>%
    fixef() %>%
    tidy() %>% 
    mutate(x = c(x[1], scale(x[-1], center = -1 * x[1], scale = FALSE)),
           names = c(first_line, str_replace(names[-1], "line_name", "")),
           trait = "FHBSeverity")
  
} else {
  fhb_blue <- fhb_fit_blue %>%
    fixef() %>%
    tidy() %>% 
    mutate(names = str_replace(names, "line_name", ""),
           trait = "FHBSeverity")
    
}

# Join all the data
PVV_BLUE_tidy <- list(hd_blue, ph_blue, fhb_blue) %>% 
  reduce(full_join) %>%
  rename(line_name = names, value = x) %>%
  select(line_name, trait, value)

# Summary
PVV_BLUE_tidy %>% 
  group_by(trait) %>% 
  summarize(mean = mean(value), min = min(value), max = max(value), range = max - min)

# Plot
PVV_BLUE_tidy %>%
  qplot(x = value, data = .) +
  facet_grid(facets = ~trait, scales = "free_x")

# Save the data
save_file <- file.path(pheno_dir, "PVV_pheno_BLUES.csv")
write.csv(x = PVV_BLUE_tidy, file = save_file, quote = FALSE, row.names = FALSE)

save_file <- file.path(pheno_dir, "PVV_pheno_BLUES.RData")
save("PVV_BLUE_tidy", file = save_file)

```


## Selections

Identify some candidates with early maturity, short stature, and good resistance

```{r select}

# Load the BLUEs file
load_file <- file.path(pheno_dir, "PVV_pheno_BLUES.RData")
load(load_file)

# What do the checks look like
(check_BLUE <- PVV_BLUE_tidy %>%
   filter(line_name %in% checks) %>%
   spread(trait, value))

# How many entries are better than the best check combinations?
check_mins <- check_BLUE %>% 
  summarize_at(vars(-line_name), min) %>%
  gather(trait, min) %>% 
  by_row(function(tr) 
    switch(tr$trait, FHBSeverity = fhb_lsd, HeadingDate = hd_lsd, PlantHeight = ph_lsd), .to = "LSD", .collate = "cols") %>%
  mutate(LSD_lower = min - LSD, LSD_upper = min + LSD)

# Entry BLUEs
entry_BLUE <- PVV_BLUE_tidy %>% 
  filter(line_name %in% entries) %>%
  # Add family info
  mutate(family = str_sub(line_name, start = 8, 10)) %>%
  select(line_name, family, trait, value)

cream_of_crop <- entry_BLUE %>%
  spread(trait, value) %>% 
  filter(FHBSeverity <= as.numeric(subset(check_mins, trait == "FHBSeverity", min)), 
         HeadingDate <= as.numeric(subset(check_mins, trait == "HeadingDate", min)), 
         PlantHeight <= as.numeric(subset(check_mins, trait == "PlantHeight", min))) %>%
  gather(trait, value, -line_name, -family) %>%
  # Add LSD info
  full_join(., select(check_mins, trait, LSD_lower)) %>%
  mutate(LSD_sig = value <= LSD_lower)

# Remove entries that are later than Pinnacle
entry_selected_early <- entry_BLUE %>% 
  spread(trait, value) %>% 
  filter(HeadingDate <= filter(check_BLUE, line_name == "Pinnacle") %>% pull(HeadingDate) - hd_lsd)

# Remove entries that are more severe than Conlon
entry_selected_res <- entry_selected_early %>% 
  filter(FHBSeverity <= filter(check_BLUE, line_name == "Conlon") %>% pull(FHBSeverity) - fhb_lsd)

# Remove entries greater than 67 cm
entry_selected_final <- entry_selected_res %>% 
  filter(PlantHeight <= 67)

# Plot all BLUEs
plot_data <- PVV_BLUE_tidy %>%
  mutate(check = ifelse(line_name %in% checks, line_name, "entry"),
         selected = ifelse(line_name %in% entry_selected_final$line_name, "selected", "not-selected")) %>%
  select(line_name, check, selected, trait, value) %>%
  spread(trait, value)

g <- GGally::ggpairs(data = plot_data, aes(color = selected, shape = check), columns = 4:6)

# Save file
save_file <- file.path(pheno_dir, "PVV_selected_BLUE.jpg")
ggsave(filename = save_file, plot = g, height = 8, width = 10)

# Combine with checks
selected_final <- bind_rows(entry_selected_final, check_BLUE)

save_file <- file.path(pheno_dir, "PVV_selected_BLUE.csv")
write.csv(x = selected_final, save_file, quote = FALSE, row.names = FALSE)

```



