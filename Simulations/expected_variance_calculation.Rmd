---
title: "Expection of Genetic Variance in Bi-Parental Population"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

## Introduction

The expectation of genetic variance in a bi-parental population can be derived using genome-wide marker effects. This would avoid the use of simulated populations in order to determine the genetic variance. To calculate this, we need to determine the expected variance at each segregating marker and the covariance between those segregating markers.

@Zhong2007 lay out nice theory for calculaing the expected mean genotypic value and expected genetic variance of the homozygous lines of a bi-parental cross. Assuming $L$ QTL and $L_m$ ($L_m \le L$) segregating QTL in cross $m$, and an additive-only model, the expected genetic variance is


$$
V_{G(m)} = \sigma^2_{G(m)} = \sum^{L_{m}}_{i=1} var(sQ_{ij(m)} ) + 2 \sum_{i \lt j} cov(sQ_{ik(m)}, sQ_{jk(m)}) 
$$

where $sQ_{ik(m)}$ is the effect of segregating QTL $i$ in progeny $k$ of cross $m$. If the homozygous effects are $+\alpha_i$ and $-\alpha_i$ for QTL $i$ and $+\alpha_j$ and $-\alpha_j$ for QTL $j$, and the two QTL recombine with rate $c_{ij}$, then the equation above can be rewritten as

$$
\sigma^2_{A(m)} = \sum^{L_{m}}_{i=1} 2 p_i q_i \alpha^2_i + 
2 \sum_{i \lt j} \frac{1 - 2 c_{ij}}{1 + 2 c_{ij}} \alpha_i \alpha_j
$$

and 

$$
\sigma^2_{G(m)} = 2 \sigma^2_{A(m)}
$$

for a population of recombinant inbred lines.


Because we do not know the effect of QTL, we can use marker effects instead. Therefore genetic variance can be predicted for a cross using marker effects, parental genotypes, and a genetic map.



Let us test this using R/qtl

Let's say there are 7 chromosomes of 100 cM each, with markers spaced every 5 cM (21 markers per chromosome).

```{r two.unlinked, echo=TRUE}

library(qtl)
library(rrBLUP)
library(dplyr)
library(purrr)

mar_len <- 100
cM_per_mar <- 0.5

# Create a map
map <- sim.map(len = rep(100, 7), n.mar = (mar_len / cM_per_mar) + 1, include.x = F, eq.spacing = T)

# The expected allele frequencies in a bi-parental RIL are p = q = 0.5
p <- q <- 0.5

# Simulate marker effects
n_mar <- sum(nmar(map))
u <- rnorm(n_mar) %>% 
  split(rep(1:nchr(map), each = (mar_len / cM_per_mar) + 1)) %>%
  mapply(map, FUN = function(u_chr, map_chr)
    structure(u_chr, names = names(map_chr)), SIMPLIFY = FALSE )

# Simulate founder parents
parents <- simFounderSnps(map = map, n.str = 4) %>%
  lapply("[", ,1:2) %>%
  lapply(FUN = function(chr) ifelse(chr == 0, -1, chr)) %>%
  lapply(t) %>%
  mapply(map, FUN = function(par_chr, map_chr)
    structure(par_chr, dimnames = list(NULL, names(map_chr))) , SIMPLIFY = FALSE)



# Generate a population to use as a training set
cross <- sim.cross(map = map, n.ind = 200, map.function = "haldane", type = "riself")

# Recode progeny genotypes
prog_geno <- mapply(cross$geno, parents, FUN = function(prog_chr, par_chr) {
  # Index over markers
  j <- seq(ncol(par_chr))
  t(apply(X = prog_chr$data, MARGIN = 1, FUN = function(prog)
    par_chr[cbind(prog, j)] )) }, SIMPLIFY = FALSE) %>%
  mapply(map, FUN = function(prog_chr, map_chr)
    structure(prog_chr, dimnames = list(NULL, names(map_chr))) , SIMPLIFY = FALSE)

# The median marker on each chromosome is the QTL
med_mar <- median(seq(nmar(map)[1]))

prog_g <- lapply(prog_geno, "[", ,med_mar, drop = FALSE) %>%
  do.call("cbind", .) %>%
  rowSums() %>%
  as.matrix()

# Take out the QTL
prog_marker_geno <- prog_geno %>%
  lapply("[", ,-med_mar)

# Calculate marker effects
Z <- do.call("cbind", prog_marker_geno)
y <- prog_g
u <- mixed.solve(y = y, Z = Z, method = "REML")$u

# Take out the QTL from the map
map_use <- map %>% 
  lapply(function(chr) chr[intersect(names(u), names(chr))] )

# Split the marker effects
u_use <- map_use %>% 
  lapply(FUN = function(chr) u[names(chr)])




# Combine marker name, position, and effect
# Also add parental genotypes and determine if the marker is segregating
mar_specs <- pmap(list(map_use, u_use), function(map_chr, u_chr) {
  data.frame(mar = names(map_chr),
             pos = as.numeric(map_chr),
             eff = u_chr,
             stringsAsFactors = FALSE) })

# Calculate the pairwise distance between markers
mar_specs_pair <- mar_specs %>%
  map(function(mar_chr) {
    
    # Pairwise combinations of markers
    mar_pairs <- combn(x = mar_chr$mar, m = 2) %>% 
      t() %>% 
      data.frame(stringsAsFactors = FALSE) %>% 
      structure(names = c("mar1", "mar2"))
    
    mar_pairs %>% 
      mutate(mar1_eff = mar_chr[mar1, "eff"], 
             mar2_eff = mar_chr[mar2, "eff"], 
             mar1_pos = mar_chr[mar1, "pos"], 
             mar2_pos = mar_chr[mar2, "pos"],
             d = abs(mar1_pos - mar2_pos),
             c_ij = mf.h(d)) %>%
      select(mar1:mar2_eff, c_ij) })
    

# Simulate founder parents
sample_ind <- sample(nind(cross), 2)
parents <- prog_geno %>% 
  lapply("[", sample_ind,, drop = FALSE)


# Which markers are segregating?
mar_seg <- parents %>% 
  map(apply, MARGIN = 2, FUN = function(snp) n_distinct(snp) > 1) %>% 
  map(which) %>% 
  map(names)

# Subset markers that are segregating and add the genotype of the first parent
mar_specs_pair_seg <- list(mar_specs_pair, parents, mar_seg) %>%
  pmap(.f = function(specs_chr, par_chr, seg_chr) {
    specs_chr %>% 
      filter(mar1 %in% seg_chr & mar2 %in% seg_chr) %>% 
      mutate(mar1_par1 = par_chr[1,mar1], mar2_par1 = par_chr[1,mar2]) })
  

# Calculate the variance of each segregating marker
mar_var <- mar_specs_pair_seg %>%
  bind_rows() %>%
  distinct(mar1, .keep_all = TRUE) %>%
  mutate(var_a = 2 * p * q * (mar1_eff^2)) %>%
  summarize(var_a = sum(var_a))

# Calculate the covariance between marker pairs
mar_covar <- mar_specs_pair_seg %>%
  bind_rows() %>%
  # Calculate covariance
  mutate(frac = (1 - (2 * c_ij)) / (1 + (2 * c_ij)),
         eff_prod = (mar1_eff * mar1_par1) * (mar2_eff * mar2_par1),
         cov = frac * eff_prod ) %>%
  summarize(covar = sum(cov))

# Calculate genetic variance from above equation
sig_A_hat1 <- as.numeric(mar_var + (2 * mar_covar))
sig_G_hat1 <- 2 * sig_A_hat1

# Test via sim.cross at 100 replications
sig_G_list <- replicate(1000, {

  cross <- sim.cross(map = map, n.ind = 200, map.function = "haldane", type = "riself")

  # Recode progeny genotypes
  prog_geno <- mapply(cross$geno, parents, FUN = function(prog_chr, par_chr) {
    # Index over markers
    j <- seq(ncol(par_chr))
    t(apply(X = prog_chr$data, MARGIN = 1, FUN = function(prog)
      par_chr[cbind(prog, j)] )) }, SIMPLIFY = FALSE)
  
  # Calculate the TRUE genetic variance
  varG_true <- lapply(prog_geno, "[", ,med_mar, drop = FALSE) %>%
    do.call("cbind", .) %>%
    rowSums() %>%
    as.matrix() %>%
    var()
  
  # Remove the QTL
  prog_geno <- prog_geno %>%
    lapply("[", ,-med_mar, drop = FALSE)
  
  # Calculate progeny genotypic value
  prog_g <- mapply(prog_geno, u_use, FUN = `%*%`) %>% 
    rowSums() %>% 
    as.matrix()
  
  # Calculate V_G
  varG_pred <- var(prog_g) 
  
  # Return true and predicted
  c(varG_true = varG_true, varG_pred = varG_pred) }, simplify = TRUE)

# Calculate the mean and sd
sig_G_list_mets <- apply(X = sig_G_list, MARGIN = 1, FUN = function(vars) c(mean(vars), sd(vars)))




```

```{r}
c(sig_G_hat1 = sig_G_hat1, rowMeans(sig_G_list))
```




## References